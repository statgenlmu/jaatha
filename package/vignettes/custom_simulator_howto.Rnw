% \VignetteIndexEntry{Using Jaatha with a custom simulation method}
% \VignetteDepends{jaatha}
% \VignettePackage{jaatha}
% \VignetteEngine{knitr::knitr}

\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

\usepackage{natbib}
\usepackage{graphics}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{hyperref}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
jinfo <- packageDescription("jaatha")
@

\hypersetup{
	pdftitle={Using Jaatha with a Custom Simulation Method \Sexpr{jinfo$Version}},
	pdfauthor={\Sexpr{jinfo$Author}},
	colorlinks=true,
	linkcolor=black,      % color of internal links
	citecolor=black,      % color of links to bibliography
	filecolor=black,      % color of file links
	urlcolor=blue         % color of external links
}

\begin{document}

\title{Using Jaatha with a Custom Simulation Method}
\author{\Sexpr{jinfo$Author}}
\date{Version \Sexpr{jinfo$Version}}
\maketitle

%\section{Introduction}
\noindent
We originally designed Jaatha for Demographic Inference in Population 
Genetics\footnote{Please consult Jaatha's other vignette, ``The Jaatha HowTo'', if you
want to use Jaatha in for Demographic Inference.}. 
As the algorithms turned out to work quite well there, we think that it might be
useful in other situations as well. Jaatha should work in the following
scenario:

\begin{itemize}
  \item You have data that is (assumed to be) generated by a parametric model
    and is -- at least approximately -- a sample from independent Poisson variables 
    under that model.
  \item You want maximum likelihood estimates for the parameter values
    generating your data, but the likelihood function is analytically
    untraceable. 
  \item You can simulate data for different parameter values under your model.
\end{itemize}

\noindent
In this document, we will explain how you can use Jaatha in such a situation and
provide step-by-step instructions for a toy example. We recommend that you first read
``The Jaatha HowTo'' or your current publication about Jaatha (\cite{mathew_why_2013}) to
understand how the algorithm works.

For the sake of simplicity, we will assume that the toy model just consists of $30$
independent Poisson variables, where the first ten have mean $x$, the second
ten have mean $y$ and the last ten have mean $z$, with 
$x, y, z \in (0,\infty)$. For given values of $x$, $y$ and $z$ we can simulate
data under this model with the function:  

<<SetupModel>>=
sampleFromModel <- function(x, y, z){
  return( c(rpois(10, x), rpois(10, y), rpois(10, z)) )
}
@

\noindent
Assume that we have observed data that was generated with the true, but
unknown parameters $x=3$, $y=5$ and $z=7.5$. Lets try to estimate this values 
from the data.
<<SampleData>>=
set.seed(5)
data.observed <- sampleFromModel(3, 5, 7.5)
data.observed
@
\noindent
Of course, the arithmetic mean is a well-known unbiased, maximum likelihoods estimator 
for $x$, $y$ and $z$ 
<<MLEstimates>>=
c(x=mean(data.observed[1:10]), 
  y=mean(data.observed[11:20]), 
  z=mean(data.observed[21:30]))
@

\noindent
but for this example, we will try using Jaatha for the estimation.

Additionally to the observed data \verb@data.observed@, we need two more objects to run Jaatha
with our model:
\begin{itemize}
\item A function \verb@sim.func@ that simulates data according to our
      model and
\item A $n\times 2$-Matrix that gives the minimal and maximal values for the
  $n$ parameters we want to estimate.
\end{itemize}
%
The function for the simulation must take exactly two arguments, first the
jaatha object and second an $n\times m$-matrix, in which each of the $m$ rows is
a complete set of the $n$ model parameters. The function should do a simulation for
each row and return the simulated values, again as a matrix with $m$
rows, stating the simulation result of the corresponding rows in the
input matrix. 

In our example $n = 3$ and we can write a simple wrapper functions for
\verb@sampleFromModel@ to give it the required form:
%
<<sim.func>>=
sim.func <- function(jaatha, sim.pars) {
  t(apply(sim.pars, 1, 
          function(x) sampleFromModel(x[1], x[2], x[3])))
}
# An example call
sim.pars <- matrix(1:6, 2, 3, byrow=TRUE)
print(sim.pars)
sim.func(sim.pars=sim.pars)
@

\noindent
Here we don't need the \verb@jaatha@ parameter. It could be used for passing 
additional parameters to the simulation function. We will explain how to do 
this in a moment.

As mentioned, the matrix that gives the parameter ranges should be of dimension
$m\times 2$. Each row consists of the minimal and maximal values of the range that the parameter can
take. Restricting the range of the parameters is required at the moment. Jaatha
also reads the names of the parameters from this matrix, so providing row names
makes the output of Jaatha easier to read, but is not required for it to run. In
our example, the matrix could look like this:
<<par.ranges>>=
par.ranges <- matrix(c(0.1, 0.1, 0.1, 10, 10, 10), 3, 2)
rownames(par.ranges) <- c('x', 'y', 'z')
colnames(par.ranges) <- c('min', 'max')
par.ranges
@

Now, we can use these three objects to initialize Jaatha:
<<initializeJaatha>>=
library(jaatha)
jaatha <- new('Jaatha', sim.func, par.ranges, data.observed) 
@

\noindent
From this point on, we can continue as described in ``The Jaatha HowTo'' by
calling \verb@Jaatha.initialSearch@ and a \verb@Jaatha.refinedSearch@. We will
do so in a moment, but first cover a few open points.

First, if you want pass additional variables to the simulation function, you can
use the \verb@opts@-slot of the jaatha object, which holds a normal list. So
say you don't want to hard code the ten variables per parameter in our model,
you could call
<<setAdditionalParameters>>=
jaatha@opts[['variable.number']] <- 10 
@
\noindent
after you created the jaatha object with \verb@new@, and use 
<<getAdditionalParameters>>=
jaatha@opts[['variable.number']]
@
\noindent
in \verb@sim.func@ to access it again. Note that this values must be the same
for all simulations. It is better to save variables need for the simulation
in the Jaatha object rather than in the normal R-Workspace, as this ensures 
that Jaatha call are reproducible as long as the same Jaatha-Object is used.  

Second, if your simulation requires temporary files, we strongly recommend to use 
the function \verb@jaatha:::getTempFile(``some.identifier'')@ to generate a file
name. This will makes sure that the different threats of Jaatha don't interact
if the program is run on multiple cores in parallel. 

Finally, the options \verb@use.shm@ for placing temporary files in memory, and
\verb@cores@ and \verb@sim.packes.size@ for parallelization are implement in the
base algorithm an can also be used along with your custom simulation function.
Just add the options to the \verb@new@ call. These options are 
described in \verb@?Jaatha.initialize@. 

\noindent
So, lets see how Jaatha performs in your toy example:
<<runJaatha, cache=TRUE>>=
jaatha <- Jaatha.initialSearch(jaatha, 100, 2)
jaatha <- Jaatha.refinedSearch(jaatha, 2, 100)
@

\noindent
Hence, Jaatha's best estimates are quite comparable to the direct maximum likelihoods
estimates for this simple model.

\bibliographystyle{plainnat}
\inputencoding{utf8}
\bibliography{jaatha_utf8}
%\inputencoding{utf8}

\end{document}
